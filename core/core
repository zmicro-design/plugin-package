#!/bin/bash

package::get_path() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::get_path] name is required"
    exit 1
  fi

  echo $PACKAGES_PATH/$name
}

package::get_package_repo_url() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::get_package_repo_url] name is required"
    exit 1
  fi

  echo ${PACKAGES_REPO_PREFIX}${name}
}

package::get_mod_path() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::get_mod_path] name is required"
    exit 1
  fi

  local package_path=$(package::get_path $name)
  echo $package_path/mod
}

package::get_config_path() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::get_config_path] name is required"
    exit 1
  fi

  local package_path=$(package::get_path $name)
  echo $package_path/config
}

package::get_core_path() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::get_core_path] name is required"
    exit 1
  fi

  local package_path=$(package::get_path $name)
  echo $package_path/core
}

package::get_bin_zmicro_path() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::get_bin_zmicro_path] name is required"
    exit 1
  fi

  local package_path=$(package::get_path $name)
  echo $package_path/bin/zmicro
}

package::load_mod() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::load_mod] name is required"
    exit 1
  fi

  local package_mod_path=$(package::get_mod_path $name)
  if [ ! -f $package_mod_path ]; then
    log::error "[$(timestamp)][package::load_mod] name is required"
    exit 1
  fi

  config::load_file $package_mod_path
}

package::load_config() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::load_config] name is required"
    exit 1
  fi

  local config_path=$(package::get_config_path $name)
  if [ -f $config_path ]; then
    config::load_file $config_path
  fi
}

package::load_core() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::load_core] name is required"
    exit 1
  fi

  local core_path=$(package::get_core_path $name)
  if [ -f $core_path ]; then
    config::load_file $core_path
  fi
}

package::register() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::register] name is required"
    exit 1
  fi

  if [ ! -w "$ZMICRO_BIN_PATH" ]; then
    sudo chmod a+rw $ZMICRO_BIN_PATH
  fi

  if [ ! -w "$ZMICRO_SUB_BIN_PATH" ]; then
    sudo chmod a+rw $ZMICRO_SUB_BIN_PATH
  fi

  local package_path=$(package::get_path $name)
  local package_bin_zmicro_path=$(package::get_bin_zmicro_path $name)
  if [ -d $package_bin_zmicro_path ]; then
    run() {
      local index=$1
      local bin=$2
      local source_path=$package_path/bin/zmicro/$bin
      local target_path=$ZMICRO_SUB_BIN_PATH/$bin
      local is_alias=false

      if [ "$bin" = "alias" ]; then
        is_alias=true
        log::info "[$(timestamp)] alias => $name ..."
        target_path=$ZMICRO_SUB_BIN_PATH/$name
      fi

      if [ ! -f $source_path ]; then
        log::error "[$(timestamp)][package::run][bin] ignore ($source_path is not valid file)"
        return
      elif [ -f $target_path ]; then
        local link_path=$(readlink $target_path)
        if [ "$link_path" != "$source_path" ]; then
          log::error "[$(timestamp)][package::run][bin] name $bin has been used"
          exit 1
        fi
        return
      fi

      if [ "$is_alias" != "true" ]; then
        log::success "[$(timestamp)][package::run] register zmicro bin: $(color::green ${bin})"
      else
        log::success "[$(timestamp)][package::run] register zmicro bin: $(color::green ${name})"
      fi

      ln -sf $source_path $target_path
    }

    array::each run $(ls $package_bin_zmicro_path)
  fi
}

package::unregister() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::unregister] name is required"
    exit 1
  fi

  local package_path=$(package::get_path $name)
  local package_bin_zmicro_path=$(package::get_bin_zmicro_path $name)
  if [ -d $package_bin_zmicro_path ]; then
    run() {
      local index=$1
      local bin=$2
      local source_path=$package_path/bin/zmicro/$bin
      local target_path=$ZMICRO_SUB_BIN_PATH/$bin

      if [ ! -f $source_path ]; then
        log::error "[$(timestamp)][package::run][bin] $source_path is not valid file"
        exit 1
      elif [ ! -f $target_path ]; then
        log::warn "[$(timestamp)][package::run][bin] name $bin not found or removed"
        return
      fi

      log::success "[$(timestamp)][package::run] unregister zmicro bin: $(color::red ${bin})"
      unlink $target_path
    }

    array::each run $(ls $package_bin_zmicro_path)
  fi
}

package::clone() {
  local name=$1
  local version=$2
  local args=${@:3}

  local error_log=$(os::tmp_file)

  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::clone] name is required"
    exit 1
  fi

  if [ -z "$version" ]; then
    version=master
  fi

  # using smart proxy
  net::using_smart_proxy 2>&1

  local package_path=$(package::get_path $name)
  local package_repo_url=$(package::get_package_repo_url $name)
  if [ ! -d "$package_path" ]; then
    # curl -I $package_repo_url 2>>/dev/null | head -n 1 | grep 404 >>/dev/null 2>&1
    # if [ "$?" = "0" ]; then
    #   log::error "[$(timestamp)][package::clone] package ${name} is not available"
    #   exit 1
    # fi

    local status_code=$(curl -s -o /dev/null -w "%{http_code}" $package_repo_url)
    if [ "$status_code" = "404" ]; then
      log::error "[$(timestamp)][package::clone] ${name} is not a package"
      exit 1
    fi

    git clone $package_repo_url -b $version $package_path >>$ZMICRO_LOG_COMMON_PATH 2>$error_log
    if [ "$?" != "0" ]; then
      log::error "[$(timestamp)][package::clone] error $name($version) ..."
      cat $error_log
      exit 1
    fi
  else
    cd $package_path
    local current_tag=$(git describe --tags)
    if [ "$current_tag" != "$version" ] && [ "$version" != "master" ]; then
      # git fetch origin $version >> $ZMICRO_LOG_UPDATE_PATH 2>>$ZMICRO_LOG_ERROR_PATH
      git fetch origin >>$ZMICRO_LOG_UPDATE_PATH 2>$error_log
      if [ "$?" != "0" ]; then
        echo "[$(timestamp)][package::clone] git fetch error ${name} ..."
        cat $error_log
        exit -1
      fi

      local tag=$version
      # 1. if tag branch exist, remove it
      git branch | grep $tag >>/dev/null 2>&1
      if [ "$?" = "0" ]; then
        git branch -D $tag >>/dev/null 2>&1
      fi

      # 2. checkout tag branch
      git checkout -b $version $tag >>$ZMICRO_LOG_UPDATE_PATH 2>$error_log
      if [ "$?" != "0" ]; then
        echo "[$(timestamp)][package::clone] git checkout error ${name} ..."
        cat $error_log
        exit -1
      fi
    fi

    # 3. update tag branch
    git pull origin $version >>$ZMICRO_LOG_UPDATE_PATH 2>>$ZMICRO_LOG_ERROR_PATH
    if [ "$?" != "0" ]; then
      echo "[$(timestamp)][package::clone] update package repo ${name} ..."
      tail -n 50 $ZMICRO_LOG_ERROR_PATH
      exit -1
    fi
  fi
}

package::install() {
  local name=$1
  local version=$2
  local args=${@:3}

  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::install] name is required"
    exit 1
  fi

  # @FEAT support: zmicro package install $name@$version
  # @example zmicro package install name@version
  if [ "$(string::match $name @)" = "true" ]; then
    version=$(echo $name | awk -F@ '{print $2}')
    name=$(echo $name | awk -F@ '{print $1}')
  fi

  if [ -z "$version" ]; then
    version=master
  elif [ "$version" = "latest" ]; then
    version=master
  fi

  if [ -n "$NO_PULL" ]; then
    echo "no pull code" >>/dev/null 2>&1
  elif [ "$version" = "--local" ]; then
    # @TODO support local package
    echo "no pull code" >>/dev/null 2>&1
  else
    package::clone $name $version $args
  fi

  local package_path=$(package::get_path $name)
  local action=install
  local package_action_path=$package_path/$action
  if [ ! -f "$package_action_path" ]; then
    log::error "[$(timestamp)][package::install] package(${name}) found, but action(${action}) is not available"
    exit 1
  fi

  # 1. Before Run Action
  # 1.1 Load Config
  package::load_config $name

  # 1.2 Load Core
  package::load_core $name

  # 1.3 Inject environment
  package::load_mod $name
  export PACKAGE_NAME=$name
  export PACKAGE_VERSION=$VERSION
  export PACKAGE_DESCRIPTION=$DESCRIPTION
  export PACKAGE_OS_ARCH="$(os::arch)"
  export PACKAGE_OS_KERNEL="$(os::kernel)"
  export PACKAGE_OS_PLATFORM="$(os::platform)"
  export PACKAGE_OS_DISTRIBUTION="$(os::distribution)"
  export PACKAGE_USER_BIN_DIR="$(os::usr_bin_dir)"
  export PACKAGE_TMP_DIR="$(os::tmp_dir)/package-${name}"
  if [ ! -d "$PACKAGE_TMP_DIR" ]; then
    mkdir -p $PACKAGE_TMP_DIR
  fi

  log::info "[$(timestamp)][package::install] $name($version) ..."
  # @FIX donot pass version
  # $package_action_path $version $args
  $package_action_path $args
  if [ "$?" != "0" ]; then
    log::error "[$(timestamp)][package::install] failed to install $name."
    return 1
  fi

  # 3. After Run Action
  package::register $name

  local version=$(package::version $name)
  log::success "[$(timestamp)][package::install][done] $name($version) ..."
}

package::remove() {
  local name=$1
  local args=${@:2}

  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::remove] name is required"
    exit 1
  fi

  local package_path=$(package::get_path $name)
  if [ ! -d "$package_path" ]; then
    log::error "[$(timestamp)][package::remove] package(${name}) not found"
    # exit 1
    return
  fi

  local action=remove
  local package_action_path=$package_path/$action
  if [ ! -f "$package_action_path" ]; then
    log::error "[$(timestamp)][package::remove] package(${name}) found, but action(${action}) is not available"
    exit 1
  fi

  log::info "[$(timestamp)][package::remove] $name"

  # 1. Before Run Action
  # 1.1 Load Config
  package::load_config $name

  # 1.2 Load Core
  package::load_core $name

  # 1.3 Inject environment
  package::load_mod $name
  export PACKAGE_NAME=$name
  export PACKAGE_VERSION=$VERSION
  export PACKAGE_DESCRIPTION=$DESCRIPTION

  # 2. Run Action
  # 2.1 Unregister bin
  package::unregister $name
  # 2.2 Run Action
  $package_action_path $args

  rm -rf $package_path

  log::success "[$(timestamp)][package::remove][done] $name"
}

package::update() {
  local name=$1
  local version=$2
  local args=${@:3}

  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::update] name is required"
    exit 1
  fi

  if [ -z "$version" ]; then
    version=master
  fi

  local package_path=$(package::get_path $name)
  local package_repo_url=$(package::get_package_repo_url $name)
  if [ ! -d "$package_path" ]; then
    log::error "[$(timestamp)][package::update] package($name) not found"
    exit 1
  fi

  # using smart proxy
  net::using_smart_proxy 2>&1

  cd $package_path
  git pull origin master >>$ZMICRO_LOG_UPDATE_PATH 2>>$ZMICRO_LOG_ERROR_PATH
  if [ "$?" != "0" ]; then
    echo "[$(timestamp)][package::update] update package repo ${name} ..."
    tail -n 50 $ZMICRO_LOG_ERROR_PATH
    exit -1
  fi

  local action=update
  local package_action_path=$package_path/$action
  if [ ! -f "$package_action_path" ]; then
    # log::error "[$(timestamp)][package::update] package(${name}) found, but action(${action}) is not available"
    # exit 1
    package::install $name $version $args
    return
  fi

  # 1. Before Run Action
  # 1.1 Load Config
  package::load_config $name

  # 1.2 Load Core
  package::load_core $name

  # 1.3 Inject environment
  package::load_mod $name
  export PACKAGE_NAME=$name
  export PACKAGE_VERSION=$VERSION
  export PACKAGE_DESCRIPTION=$DESCRIPTION

  log::info "[$(timestamp)][package::update] $name ..."
  $package_action_path $args

  # 3. After Run Action
  package::register $name

  local version=$(package::version $name)
  log::success "[$(timestamp)][package::update][done] $name($version) ..."
}

package::reinstall() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::reinstall] name is required"
    exit 1
  fi

  log::info "[$(timestamp)][package::reinstall] $name ..."

  local package_path=$(package::get_path $name)
  package::clone $name

  local action=reinstall
  local package_action_path=$package_path/$action
  if [ ! -f "$package_action_path" ]; then
    package::install $name
  else
    $package_action_path $args
  fi

  local version=$(package::version $name)
  log::success "[$(timestamp)][package::reinstall][done] $name($version) ..."
}

package::run() {
  package::force_sudo

  local action=$1
  local name=$2
  local args=${@:3}

  if [ -z "$action" ]; then
    log::error "[$(timestamp)][package::run] action is required"
    exit 1
  fi

  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::run] name is required"
    exit 1
  fi

  # 2. Run Action => install / remove / update / reinstall
  log::debug "[$(timestamp)][package::run] $name $action $args"
  case $action in
  install)
    package::install $name $args
    ;;
  remove)
    package::remove $name $args
    ;;
  reinstall)
    package::reinstall $name $args
    ;;
  update)
    package::update $name $args
    ;;
  *)
    log::error "[$(timestamp)][package::run] unkown action(${action}) in ${action} ${name} ${args}"
    exit 1
    ;;
  esac
}

package::list() {
  local packages=$(ls $PACKAGES_PATH)
  local index=1
  for name in $packages; do
    echo "[$index] $name"
    index=$((index + 1))
  done
}

package::version() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::version] name is required"
    exit 1
  fi

  # @TODO
  if [ ! -f "$(package::get_mod_path $name)" ]; then
    echo "-"
    return
  fi

  package::load_mod $name
  echo $VERSION
}

package::description() {
  local name=$1
  if [ -z "$name" ]; then
    log::error "[$(timestamp)][package::description] name is required"
    exit 1
  fi

  if [ ! -f "$(package::get_mod_path $name)" ]; then
    echo "No Description"
    return
  fi

  package::load_mod $name
  echo $DESCRIPTION
}

package::force_sudo() {
  # use force sudo to get required permissions
  sudo ps >>/dev/null 2>&1
}

export -f package::get_path
export -f package::get_package_repo_url

export -f package::get_mod_path
export -f package::get_config_path
export -f package::get_core_path
export -f package::get_bin_zmicro_path

export -f package::load_mod
export -f package::load_config
export -f package::load_core

export -f package::register
export -f package::unregister

export -f package::clone

export -f package::install
export -f package::remove
export -f package::update
export -f package::reinstall

export -f package::run
export -f package::list

export -f package::version
export -f package::description

# export -f package::release

export -f package::force_sudo
